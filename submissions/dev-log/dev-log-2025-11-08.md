# 開發日誌 - 2025-11-08

## 日期與開發者
- **日期**: 2025年11月8日
- **分支**: `feat/submissions-API`
- **開發階段**: 測試修復與整合

---

## 工作概要

今天的主要工作是修復測試套件中的錯誤，並且測試上次沒有測試到的部分，確保所有 69 個測試都能通過。工作從發現 19 個測試失敗開始，經過系統性的問題分析和修復，最終達到 100% 測試通過率。

### 測試統計
- **測試總數**: 69 個
- **初始失敗**: 19 個錯誤
- **最終結果**: 69/69 通過 (100%)
- **執行時間**: 19.454 秒

---

## 問題發現流程

### 1. 初始測試執行
```bash
python manage.py test submissions.test_file --keepdb -v 2
```

**發現的問題分類**:
1. URL 反向解析錯誤 (15 個測試)
2. Hypothesis 測試超時 (1 個測試)
3. 模型字段錯誤 (1 個測試)
4. Serializer 配置問題 (2 個測試)

### 2. 問題分析方法

使用系統化的問題診斷流程：

```
問題發現
  ↓
閱讀錯誤訊息 (Traceback 分析)
  ↓
檢查相關程式碼 (read_file)
  ↓
理解設計意圖 (查看 models, views, serializers)
  ↓
制定修復方案
  ↓
實施修復
  ↓
驗證結果 (重新運行測試)
```

---

## 問題詳細分析與解決方案

### 問題 1: URL 配置缺失 (Merge 衝突導致)

**錯誤訊息**:
```python
django.urls.exceptions.NoReverseMatch: 'submissions' is not a registered namespace
```

**影響範圍**: 15 個測試失敗

**根本原因**:
- Git merge 過程中，主 `urls.py` 的 submissions URL 配置被人刪除？？？
- 測試使用 `reverse('submissions:editorial-list-create')` 無法解析

**分析過程**:
1. 檢查錯誤堆疊，發現 `django.urls.base.py` 拋出 `KeyError: 'submissions'`
2. 檢查 `back_end/urls.py`，確認缺少 submissions 的 include
3. 檢查 `submissions/urls.py`，確認路由定義正確，有 `app_name = 'submissions'`

**解決方案**:
```python
# back_end/urls.py
urlpatterns = [
    path('admin/', admin.site.urls),
    path('user/', include('user.urls')), 
    path('course/', include('courses.urls')),
    path('auth/', include('auths.urls')),
    path('submissions/', include('submissions.urls')),  # ← 添加此行
]
```

**驗證結果**: 15 個測試從失敗變為通過

---

### 問題 2: Hypothesis 測試超時

**錯誤訊息**:
```python
hypothesis.errors.DeadlineExceeded: Test took 1008.88ms, which exceeds the deadline of 1000.00ms
```

**影響範圍**: `test_multiple_course_members_permissions`

**根本原因**:
- 測試創建多個用戶（最多 1 teacher + 3 TAs + 10 students = 14 users）
- Django 的 PBKDF2 密碼哈希每個用戶需要 50-100ms
- 總時間超過 1000ms deadline

**分析過程**:
1. 查看 Hypothesis 錯誤訊息中的 "Falsifying example"
2. 發現失敗案例: `num_teachers=1, num_tas=0, num_students=9`
3. 計算: 10 users × 100ms ≈ 1000ms，剛好超過 deadline
4. 檢查測試邏輯，確認沒有性能問題，只是密碼哈希開銷大

**解決方案**:
```python
@settings(max_examples=5, deadline=2000)  # 從 1000ms 增加到 2000ms
def test_multiple_course_members_permissions(self, num_teachers, num_tas, num_students):
```

**技術考量**:
- 增加 deadline 而非優化測試邏輯，因為真實場景就是需要創建多個用戶
- 2000ms 足夠覆蓋最壞情況（14 users × 100ms = 1400ms）

**驗證結果**: 測試穩定通過，執行時間約 1500ms

---

### 問題 3: SubmissionResult 模型字段錯誤

**錯誤訊息**:
```python
TypeError: SubmissionResult() got unexpected keyword arguments: 'task_id'
```

**影響範圍**: `test_submission_result_creation`

**根本原因**:
- 測試使用了不存在的 `task_id` 字段
- 實際模型使用 `test_case_id` 和 `problem_id`

**分析過程**:
1. 檢查錯誤訊息，發現 `task_id` 參數不被接受
2. 閱讀 `submissions/models.py` 中 SubmissionResult 定義
3. 發現正確字段為: `test_case_id`, `test_case_index`, `problem_id`

**解決方案**:
```python
# 修改前
@given(
    task_id=st.text(min_size=1, max_size=50),
    ...
)
def test_submission_result_creation(self, task_id, ...):
    result = SubmissionResult.objects.create(
        submission=self.submission,
        task_id=task_id,  # 錯誤字段
        ...
    )

# 修改後
@given(
    test_case_id=st.integers(min_value=1, max_value=100),
    ...
)
def test_submission_result_creation(self, test_case_id, ...):
    result = SubmissionResult.objects.create(
        submission=self.submission,
        problem_id=1,           # 添加必需字段
        test_case_id=test_case_id,  # 正確字段
        ...
    )
```

**驗證結果**: 測試通過，模型創建成功

---

### 問題 4: Editorial Serializer 配置不一致

**錯誤訊息**:
```python
AssertionError: Failed with data: {...}, errors: {'problem_id': [ErrorDetail(string='This field is required.', code='required')]}
```

**影響範圍**: 
- `test_teacher_can_create_editorial_with_random_data`
- `test_ta_can_create_editorial`
- `test_editorial_create_serializer_valid_data`

**根本原因**:
- `EditorialCreateSerializer` 的設計是從 URL 路徑獲取 `problem_id`
- View 的 `perform_create()` 方法會自動設置 `problem_id`
- 但 serializer 的 `fields` 中包含了 `problem_id`，導致驗證時要求必填

**分析過程**:
1. 檢查 API 測試，發現沒有在 POST data 中包含 `problem_id`
2. 檢查 `views.py` 的 `EditorialListCreateView.perform_create()`
   ```python
   def perform_create(self, serializer):
       problem_id = self.kwargs['problem_id']  # 從 URL 路徑獲取
       serializer.save(problem_id=problem_id, ...)
   ```
3. 理解設計意圖: REST API 設計中，`problem_id` 應該從 URL 中獲取
   - URL: `/problem/<problem_id>/solution/`
   - 符合 RESTful 資源嵌套設計

**解決方案**:
```python
# EditorialCreateSerializer - 移除 problem_id
class Meta:
    model = Editorial
    fields = ['id', 'title', 'content', 'difficulty_rating', 'is_official']
    # 不包含 'problem_id'，因為由 view 設置
    read_only_fields = ['id']

# EditorialSerializer - 保留 problem_id（用於讀取）
class Meta:
    model = Editorial
    fields = '__all__'  # 包含所有字段，包括 problem_id
    read_only_fields = ['id', 'problem_id', 'author', ...]
```

**單元測試修復**:
```python
# 測試 serializer 時需要模擬 view 的行為
serializer = EditorialCreateSerializer(data=data, context={'request': request})
assert serializer.is_valid()
editorial = serializer.save(problem_id=1)  # 模擬 view.perform_create()
```

**設計模式總結**:
- **創建時** (POST): `problem_id` 從 URL 路徑獲取，不在 request body 中
- **讀取時** (GET): `problem_id` 包含在響應中，讓客戶端知道所屬問題

**驗證結果**: 5 個測試從失敗變為通過

---

### 問題 5: Decimal 精度比較問題

**錯誤訊息**:
```python
AssertionError
# difficulty_rating 比較失敗: 1.2 != Decimal('1.2')
```

**影響範圍**: `test_editorial_create_serializer_valid_data`

**根本原因**:
- 測試使用 float 類型 (1.2)
- 資料庫保存為 Decimal 類型
- Python 的 `==` 運算符無法比較 float 和 Decimal

**分析過程**:
1. 檢查 Editorial 模型定義:
   ```python
   difficulty_rating = models.DecimalField(
       max_digits=3, 
       decimal_places=1, 
       null=True, 
       blank=True
   )
   ```
2. 理解 Decimal 和 float 的差異
3. 使用容差比較避免浮點數精度問題

**解決方案**:
```python
# 修改前
assert editorial.difficulty_rating == difficulty_rating  # 類型不匹配

# 修改後
if difficulty_rating is not None:
    from decimal import Decimal
    assert abs(float(editorial.difficulty_rating) - difficulty_rating) < 0.01
else:
    assert editorial.difficulty_rating == difficulty_rating
```

**技術要點**:
- 使用 `abs(a - b) < epsilon` 進行浮點數比較
- epsilon = 0.01 足夠處理 1 位小數的精度
- 處理 None 情況

**驗證結果**: 測試通過，支持 None 和任意有效值

---

### 問題 6: CustomTest 字符驗證問題

**錯誤訊息**:
```python
ExceptionGroup: Hypothesis found 3 distinct failures.
  1. AssertionError: assert custom_test.input_data == '\r'
  2. AssertionError: assert custom_test.expected_output == '\r'  
  3. AssertionError: Errors: {'source_code': [...'Null characters are not allowed.'...]}
```

**影響範圍**: `test_custom_test_create_serializer`

**根本原因**:
- Hypothesis 生成包含特殊字符的隨機字符串
- Django TextField 處理空白字符的方式與測試預期不一致
- Serializer 拒絕 null 字符 (`\x00`) 但測試可能生成它

**分析過程**:

1. **錯誤 1 & 2**: `\r` (回車符) 問題
   - Hypothesis 生成 `input_data='\r'`
   - Django 保存時可能規範化為 `''`
   - 斷言 `custom_test.input_data == '\r'` 失敗

2. **錯誤 3**: Null 字符問題
   - Hypothesis 生成 `source_code='\x00'`
   - Serializer 的安全驗證拒絕 null 字符
   - 測試預期所有隨機字符串都應該通過驗證

3. **根本問題**: 測試策略沒有排除不合法字符

**解決方案**:
```python
# 修改前：允許任意字符
@given(
    source_code=st.text(min_size=1, max_size=500).filter(lambda x: x.strip()),
    input_data=st.one_of(st.none(), st.text(max_size=200)),
    expected_output=st.one_of(st.none(), st.text(max_size=200))
)

# 修改後：排除控制字符和 null 字符
@given(
    source_code=st.text(
        min_size=1, 
        max_size=500,
        alphabet=st.characters(
            blacklist_categories=['Cc', 'Cs'],  # 控制字符和代理字符
            blacklist_characters=['\x00']       # null 字符
        )
    ).filter(lambda x: x.strip()),
    input_data=st.one_of(
        st.none(), 
        st.text(
            max_size=200,
            alphabet=st.characters(
                blacklist_categories=['Cs'],
                blacklist_characters=['\x00']
            )
        ).filter(lambda x: x is None or x == '' or x.strip())  # 過濾純空白
    ),
    expected_output=st.one_of(
        st.none(), 
        st.text(
            max_size=200,
            alphabet=st.characters(
                blacklist_categories=['Cs'],
                blacklist_characters=['\x00']
            )
        ).filter(lambda x: x is None or x == '' or x.strip())
    )
)
```

**字符類別說明**:
- `Cc`: Control characters (控制字符，如 `\r`, `\n`, `\x00`)
- `Cs`: Surrogate characters (Unicode 代理字符)

**過濾邏輯**:
- `source_code`: 完全排除控制字符（包括 `\r`, `\n`）
- `input_data/expected_output`: 允許換行符但排除其他控制字符
- 過濾純空白字符串，保留 `None`、空字符串或有內容的字符串

**驗證結果**: 測試穩定通過，Hypothesis 生成的所有隨機數據都合法

---

## 修復成果統計

| 問題類別 | 影響測試數 | 修復文件 | 狀態 |
|---------|----------|---------|------|
| URL 配置遺失 | 15 | `back_end/urls.py` | V |
| Hypothesis 超時 | 1 | `test_permissions.py` |V |
| 模型字段錯誤 | 1 | `test_submission_models.py` |V |
| Serializer 配置 | 5 | `serializers.py` | V|
| Decimal 精度 | 1 | `test_serializers.py` |V |
| 字符驗證 | 2 | `test_serializers.py` |V |

**總計**: 修復 6 類問題，涉及 19 個失敗測試，修改 5 個文件

---

## 修改的文件清單

### 1. `back_end/urls.py`
```python
+ path('submissions/', include('submissions.urls')),
```

### 2. `submissions/test_file/test_permissions.py`
```python
- @settings(max_examples=5, deadline=1000)
+ @settings(max_examples=5, deadline=2000)
```

### 3. `submissions/test_file/test_submission_models.py`
```python
- task_id=st.text(min_size=1, max_size=50),
+ test_case_id=st.integers(min_value=1, max_value=100),

- result = SubmissionResult.objects.create(
-     submission=self.submission,
-     task_id=task_id,
+ result = SubmissionResult.objects.create(
+     submission=self.submission,
+     problem_id=1,
+     test_case_id=test_case_id,
```

### 4. `submissions/serializers.py`
```python
class Meta:
    model = Editorial
-   fields = ['id', 'problem_id', 'title', 'content', 'difficulty_rating', 'is_official']
+   fields = ['id', 'title', 'content', 'difficulty_rating', 'is_official']
```

### 5. `submissions/test_file/test_serializers.py`

**EditorialCreateSerializer 測試**:
```python
- data = {
-     'problem_id': 1,
-     'title': title,
+ data = {
+     'title': title,
      ...
  }
- editorial = serializer.save()
+ editorial = serializer.save(problem_id=1)

- assert editorial.difficulty_rating == difficulty_rating
+ if difficulty_rating is not None:
+     assert abs(float(editorial.difficulty_rating) - difficulty_rating) < 0.01
+ else:
+     assert editorial.difficulty_rating == difficulty_rating
```

**CustomTestCreateSerializer 測試**:
```python
+ alphabet=st.characters(
+     blacklist_categories=['Cc', 'Cs'],
+     blacklist_characters=['\x00']
+ )
+ .filter(lambda x: x is None or x == '' or x.strip())
```

---

## 測試執行紀錄

### 第一次執行（修復前）
```bash
$ python manage.py test submissions.test_file --keepdb -v 2
Found 69 test(s).
...
FAILED (errors=19)
```

### 第二次執行（修復 URL 和 timeout）
```bash
$ python manage.py test submissions.test_file --keepdb -v 2
Found 69 test(s).
...
FAILED (failures=5)
```

### 第三次執行（修復 serializer 問題）
```bash
$ python manage.py test submissions.test_file --keepdb -v 2
Found 69 test(s).
...
FAILED (errors=2)
```

### 最終執行（全部通過）
```bash
$ python manage.py test submissions.test_file --keepdb -v 2
Found 69 test(s).
...
Ran 69 tests in 19.454s
OK 
```

**進步軌跡**: 19 errors → 5 failures → 2 errors → 0 errors (100% pass)

---

## 經驗總結

### 1. 系統化問題解決方法

遵循嚴格的問題解決流程：
1. **收集信息**: 完整閱讀錯誤訊息和堆疊追蹤
2. **定位問題**: 使用 `read_file` 檢查相關程式碼
3. **理解上下文**: 查看 models, views, serializers 的設計意圖
4. **制定方案**: 基於 RESTful 和 Django 最佳實踐
5. **實施修復**: 最小化修改，保持向後兼容
6. **驗證結果**: 重新運行測試確保修復有效

### 2. RESTful API 設計原則

**資源嵌套設計**:
```
/problem/<problem_id>/solution/          # 列出/創建題解
/problem/<problem_id>/solution/<id>/     # 獲取/更新/刪除特定題解
```

**數據來源分離**:
- **URL 路徑**: 資源 ID (`problem_id`)
- **Request Body**: 資源屬性 (`title`, `content`)
- **自動設置**: 上下文信息 (`author`, `created_at`)

### 3. Django Serializer 設計模式

**創建 vs 讀取分離**:
```python
# 創建時：最小化必填字段
class EditorialCreateSerializer(serializers.ModelSerializer):
    fields = ['title', 'content', ...]  # 只要求用戶輸入的字段

# 讀取時：完整信息
class EditorialSerializer(serializers.ModelSerializer):
    fields = '__all__'  # 返回所有信息
```

### 4. Hypothesis 測試策略優化

**字符生成策略**:
- 使用 `alphabet=st.characters()` 控制字符範圍
- 使用 `blacklist_categories` 排除問題字符類別
- 使用 `filter()` 進行額外驗證
- 使用 `assume()` 跳過無效測試案例

**性能考量**:
- 計算最壞情況執行時間
- 設置合理的 `deadline` 和 `max_examples`
- 在速度和覆蓋率之間取得平衡

### 5. Git Merge 衝突處理

**教訓**:
- Merge 後必須檢查配置文件（尤其是 `urls.py`）
- 運行完整測試套件驗證合併結果
- 使用 IDE 的 merge 工具可視化衝突

**預防措施**:
- 定期同步遠端分支
- 小步提交，頻繁合併
- 關鍵配置文件優先處理衝突


## 參考資源

- [Django REST Framework Serializers](https://www.django-rest-framework.org/api-guide/serializers/)
- [Hypothesis Testing Strategies](https://hypothesis.readthedocs.io/en/latest/data.html)
- [RESTful API Design Best Practices](https://restfulapi.net/)
- [Django URL Configuration](https://docs.djangoproject.com/en/stable/topics/http/urls/)

